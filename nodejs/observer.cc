#include <v8.h>
#include "mbfly_njs.h"

extern "C" {
#include <mb.h>
#include <string.h>
}

#ifndef ASSERT
#define ASSERT(x)
#endif

using namespace v8;

struct xnjsmb_observer_data {
    Persistent<Function> func;
};

static void
event_handler(event_t *evt, void *arg);

static void
xnjsmb_event_mod(Handle<Object> self, event_t *evt) {
    mouse_event_t *mevt;
    X_kb_event_t *xkbevt;
    
    switch(evt->type) {
    case EVT_ANY:
    case EVT_MOUSE_OVER:
    case EVT_MOUSE_OUT:
    case EVT_MOUSE_MOVE:
    case EVT_MOUSE_BUT_PRESS:
    case EVT_MOUSE_BUT_RELEASE:
	mevt = (mouse_event_t *)evt;
	SET(self, "x", Integer::New(mevt->x));
	SET(self, "y", Integer::New(mevt->y));
	SET(self, "but_state", Integer::New(mevt->but_state));
	SET(self, "button", Integer::New(mevt->button));
	break;
	
    case EVT_KB_PRESS:
    case EVT_KB_RELEASE:
	xkbevt = (X_kb_event_t *)evt;
	SET(self, "keycode", Integer::New(xkbevt->keycode));
	SET(self, "sym", Integer::New(xkbevt->sym));
	break;
	
    case EVT_PROGM_COMPLETE:
    case EVT_RDMAN_REDRAW:
    case EVT_MONITOR_ADD:
    case EVT_MONITOR_REMOVE:
    case EVT_MONITOR_FREE:
    case EVT_MOUSE_MOVE_RAW:
    default:
	/* Not implemented.  Do nothing. */
	break;
    }
}

static observer_t *
_subject_add_event_observer(subject_t *subject, int type,
                            Handle<Function> func) {
    observer_t *observer;
    xnjsmb_observer_data *data;
    
    data = new xnjsmb_observer_data;
    if(data == NULL)
	return NULL;
    data->func = Persistent<Function>::New(func);
    observer = subject_add_event_observer(subject, type,
					  event_handler,
    	       				  data);

    return observer;
}

static void
_subject_remove_observer(subject_t *subject, observer_t *observer) {
    xnjsmb_observer_data *data;

    subject_remove_observer(subject, observer);
    data = (xnjsmb_observer_data *)observer->arg;
    delete data;
}

static Handle<Value>
xnjsmb_event_tgt_getter(Handle<Object> self, event_t *evt, const char **err) {
    Persistent<Object> *hdl;
    
    hdl = (Persistent<Object> *)
	mb_prop_get(&((mb_obj_t *)evt->tgt)->props,
		    PROP_JSOBJ);
    return Local<Object>::New(*hdl);
}

static void
xnjsmb_event_tgt_setter(Handle<Object> self, event_t *evt,
			Handle<Value> value, const char **err) {
    *err = "Not implemented";
}

static Handle<Value>
xnjsmb_event_cur_tgt_getter(Handle<Object> self, event_t *evt,
			    const char **err) {
    Persistent<Object> *hdl;
    
    hdl = (Persistent<Object> *)
	mb_prop_get(&((mb_obj_t *)evt->cur_tgt)->props,
		    PROP_JSOBJ);
    return Local<Object>::New(*hdl);
}

static void
xnjsmb_event_cur_tgt_setter(Handle<Object> self, event_t *evt,
			    Handle<Value> value, const char **err) {
    *err = "Not implemented";
}

/* This is the part of the code generated by gen_v8_binding.m4 */
#include "observer-inc.h"

static void
event_handler(event_t *evt, void *arg) {
    xnjsmb_observer_data *data = (xnjsmb_observer_data *)arg;
    Handle<Value> evt_obj;
    Handle<Value> func_args[1];

    evt_obj = xnjsmb_auto_event_new(evt);
    ASSERT(!evt_obj.IsEmpty());
    func_args[0] = evt_obj;
    data->func->Call(Context::GetCurrent()->Global(), 1, func_args);
}

Handle<Value>
export_xnjsmb_auto_subject_new(subject_t *subject) {
    Handle<Value> val;
    
    val = xnjsmb_auto_subject_new(subject);
    return val;
}

void
xnjsmb_observer_init(void) {
    xnjsmb_auto_observer_init();
    xnjsmb_auto_subject_init();
    xnjsmb_auto_event_init();
}
